// DO NOT EDIT; automatically generated by brio-gen

package dmon

import (
	"encoding/binary"
)

// MarshalBinary implements encoding.BinaryMarshaler
func (o *Msg) MarshalBinary() (data []byte, err error) {
	var buf [8]byte
	binary.LittleEndian.PutUint64(buf[:8], uint64(o.ID))
	data = append(data, buf[:8]...)
	{
		sub, err := o.Stamp.MarshalBinary()
		if err != nil {
			return nil, err
		}
		binary.LittleEndian.PutUint64(buf[:8], uint64(len(sub)))
		data = append(data, buf[:8]...)
		data = append(data, sub...)
	}
	binary.LittleEndian.PutUint64(buf[:8], uint64(len(o.Level)))
	data = append(data, buf[:8]...)
	data = append(data, []byte(o.Level)...)
	binary.LittleEndian.PutUint64(buf[:8], uint64(len(o.System)))
	data = append(data, buf[:8]...)
	data = append(data, []byte(o.System)...)
	binary.LittleEndian.PutUint64(buf[:8], uint64(len(o.Component)))
	data = append(data, buf[:8]...)
	data = append(data, []byte(o.Component)...)
	binary.LittleEndian.PutUint64(buf[:8], uint64(len(o.Message)))
	data = append(data, buf[:8]...)
	data = append(data, []byte(o.Message)...)
	return data, err
}

// UnmarshalBinary implements encoding.BinaryUnmarshaler
func (o *Msg) UnmarshalBinary(data []byte) (err error) {
	o.ID = int64(binary.LittleEndian.Uint64(data[:8]))
	data = data[8:]
	{
		n := int(binary.LittleEndian.Uint64(data[:8]))
		data = data[8:]
		err = o.Stamp.UnmarshalBinary(data[:n])
		if err != nil {
			return err
		}
		data = data[n:]
	}
	{
		n := int(binary.LittleEndian.Uint64(data[:8]))
		data = data[8:]
		o.Level = string(data[:n])
		data = data[n:]
	}
	{
		n := int(binary.LittleEndian.Uint64(data[:8]))
		data = data[8:]
		o.System = string(data[:n])
		data = data[n:]
	}
	{
		n := int(binary.LittleEndian.Uint64(data[:8]))
		data = data[8:]
		o.Component = string(data[:n])
		data = data[n:]
	}
	{
		n := int(binary.LittleEndian.Uint64(data[:8]))
		data = data[8:]
		o.Message = string(data[:n])
		data = data[n:]
	}
	return err
}
